RPC methods:


Request:
{ method:   "createAccount",
  username: "foobar123",
  salt:     "randomstring",
  passkey:  "0123456789abcdef0123456789abcdef012345678" }

Response:
{ error:    "human-readable message",   /* if an error occurred */
  username: "foobar123" }               /* if no error occurred */

(On success, server sets signed "username" cookie.)


Request:
{ method:   "getUsername" }

Response:
{ username: "foobar123" }    /* or empty object if not logged in */


Request:
{ method:   "getAuthChallenge",
  username: "foobar123" }
Response:
{ error:    "human-readable message",   /* on error e.g. if user does not exist */
  username: "username",
  salt:     "randomstring",             /* as originally passed to "createAccount" */
  nonce:    "ASCII data" }

The client should use the salt and the user's password (which is never sent to
the server) to recreate the original passkey (as passed to "createAccount").


Request:
{ method:   "authenticate",
  username: "foobar123",                /* as returned by "getAuthChallenge" */
  nonce:    "ASCII data",               /* as returned by "getAuthChallenge" */
  proof:    "0123456789abcdef0123456789abcdef012345678" }
Response:
{ error:    "human-readable message",   /* on error e.g. wrong password */
  username: "username"                  /* authenticated username */
}

(On success, server sets signed "username" cookie.)


Request:
{ method:   "logOut" }
Response:
{ }

(Server removes the "username" cookie.)


Request:
{ method:   "createGame",
  state:    { /* gamestate created by GameState.objectify() */ } }
Response:
{ error:        "human-readable error message",
  gameId:       123,
  playerKeys:   ["xxxx","yyyy","zzzz"] }  /* array of strings; one for each player */
